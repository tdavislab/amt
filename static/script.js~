document.onload = (function(d3, saveAs, Blob, undefined){
    "use strict";
    var consts = {
	defaultTitle: "random variable"
    };
    var settings = {
	appendElSpec1: "#graph1",
	appendElSpec2: "#graph2",
	appendElSpec3: "#graph3"
	
    };
    // define graphcreator object
    var GraphCreator = function(svg, nodes, edges, Domain){
	var thisGraph = this;
	thisGraph.domain = Domain;
        thisGraph.idct = 0;
	
	thisGraph.nodes = nodes || [];
	thisGraph.edges = edges || [];
	
	thisGraph.state = {
	    selectedNode: null,
	    selectedEdge: null,
	    mouseDownNode: null,
	    mouseDownLink: null,
	    justDragged: false,
	    justScaleTransGraph: false,
	    lastKeyDown: -1,
	    shiftNodeDrag: false,
	    selectedText: null
	};

	thisGraph.consts =  {
	    selectedClass: "selected",
	    connectClass: "connect-node",
	    circleGClass: "conceptG",
	    graphClass: "graph",
	    activeEditId: "active-editing",
	    BACKSPACE_KEY: 8,
	    DELETE_KEY: 46,
	    ENTER_KEY: 13,
	    nodeRadius: 30
	};
	

	
	thisGraph.svg = svg;
	thisGraph.svgG = svg.append("g")
            .classed(thisGraph.consts.graphClass, true);
	var svgG = thisGraph.svgG;
	
	// displayed when dragging between nodes
	thisGraph.dragLine = svgG.append('svg:path')
            .attr('class', 'link dragline hidden')
            .attr('d', 'M0,0L0,0');

	// svg nodes and edges
	thisGraph.paths = svgG.append("g").selectAll("g");
	thisGraph.circles = svgG.append("g").selectAll("g");
	
	thisGraph.drag = d3.behavior.drag()
            .origin(function(d){
		return {x: d.x, y: d.y};
            })
            .on("drag", function(args){
		thisGraph.state.justDragged = true;
		thisGraph.dragmove.call(thisGraph, args);
            })
            .on("dragend", function() {
		// todo check if edge-mode is selected
            });
	// listen for key events
	d3.select(thisGraph.domain).on("keydown", function(){
	    thisGraph.svgKeyDown.call(thisGraph);
	})
	    .on("keyup", function(){
		thisGraph.svgKeyUp.call(thisGraph);
	    });
	svg.on("mousedown", function(d){thisGraph.svgMouseDown.call(thisGraph, d);});
	svg.on("mouseup", function(d){thisGraph.svgMouseUp.call(thisGraph, d);});
	
	// listen for dragging
	var dragSvg = d3.behavior.zoom()
            .on("zoom", function(){
		if (d3.event.sourceEvent.shiftKey){
		    // TODO  the internal d3 state is still changing
		    return false;
		}
		/*
		else {
		    thisGraph.zoomed.call(thisGraph);
		}
		*/
		return true;
            })
            .on("zoomstart", function(){
		var ael = d3.select("#" + thisGraph.consts.activeEditId).node();
		if (ael){
		    ael.blur();
		}
		//if (!d3.event.sourceEvent.shiftKey) d3.select('body').style("cursor", "move");
            })
            .on("zoomend", function(){
		d3.select('body').style("cursor", "auto");
            });
	
	svg.call(dragSvg).on("dblclick.zoom", null);

	// handle download data
	d3.select("#download-input").on("click", function(){
	    var saveEdges = [];
	    thisGraph.edges.forEach(function(val, i){
		saveEdges.push({source: val.source.id, target: val.target.id});
	    });
	    var blob = new Blob([window.JSON.stringify({"nodes": thisGraph.nodes, "edges": saveEdges})], {type: "text/plain;charset=utf-8"});
	    saveAs(blob, "mydag.json");
	});
	
	d3.select("#help")
	    .on("click", function(){
		alert('shift-click on graph to create a node\nshift-click on a node and then drag to another node to connect them with a edge\nshift-click on a node to change its title\nclick on node or edge and press backspace/delete to delete');
	  });
      
      
	// handle uploaded data
	d3.select("#upload-input").on("click", function(){
	    document.getElementById("hidden-file-upload").click();
	});
	
	d3.select("#hidden-file-upload").on("change", function(){
	    if (window.File && window.FileReader && window.FileList && window.Blob) {
		var uploadFile = this.files[0];
		var filereader = new window.FileReader();
		
		filereader.onload = function(){
		    var txtRes = filereader.result;
		    // TODO better error handling
		    try{
			var jsonObj = JSON.parse(txtRes);
			thisGraph.deleteGraph(true);
			thisGraph.nodes = jsonObj.nodes;
			thisGraph.setIdCt(jsonObj.nodes.length + 1);
			var newEdges = jsonObj.edges;
			newEdges.forEach(function(e, i){
			    newEdges[i] = {source: thisGraph.nodes.filter(function(n){return n.id == e.source;})[0],
					   target: thisGraph.nodes.filter(function(n){return n.id == e.target;})[0]};
			});
			thisGraph.edges = newEdges;
			thisGraph.updateGraph();
		    }catch(err){
			window.alert("Error parsing uploaded file\nerror message: " + err.message);
			return;
		    }
		};
		filereader.readAsText(uploadFile);
		
	    } else {
		alert("Your browser won't let you save this graph -- try upgrading your browser to IE 10+ or Chrome or Firefox.");
	    }
	    
	});
	
	// handle delete graph
	d3.select("#delete-graph").on("click", function(){
	    thisGraph.deleteGraph(false);
	});

	thisGraph.setIdCt = function(idct){
	    this.idct = idct;
	};

	thisGraph.dragmove = function(d) {
	    var thisGraph = this;
	    if (thisGraph.state.shiftNodeDrag){
		thisGraph.dragLine.attr('d', 'M' + d.x + ',' + d.y + 'L' + d3.mouse(thisGraph.svgG.node())[0] + ',' + d3.mouse(this.svgG.node())[1]);
	    } else{
		d.x += d3.event.dx;
		d.y +=  d3.event.dy;
		thisGraph.updateGraph();
	    }
	};
	
	thisGraph.deleteGraph = function(skipPrompt){
	    var thisGraph = this,
		doDelete = true;
	    if (!skipPrompt){
		doDelete = window.confirm("Press OK to delete this graph");
	    }
	    if(doDelete){
		thisGraph.nodes = [];
		thisGraph.edges = [];
		thisGraph.updateGraph();
	    }
	};


	/* select all text in element: taken from http://stackoverflow.com/questions/6139107/programatically-select-text-in-a-contenteditable-html-element */
	thisGraph.selectElementContents = function(el) {
	    var range = document.createRange();
	    range.selectNodeContents(el);
	    var sel = window.getSelection();
	    sel.removeAllRanges();
	    sel.addRange(range);
	};
	
    
	/* insert svg line breaks: taken from http://stackoverflow.com/questions/13241475/how-do-i-include-newlines-in-labels-in-d3-charts */
	thisGraph.insertTitleLinebreaks = function (gEl, title) {
	   
	    var words = title.split(/\s+/g),
		nwords = words.length;
	    var el = gEl.append("text")
		.attr("text-anchor","middle")
		.attr("dy", "6px")
		.attr("font-size", "25px");
	    
	    for (var i = 0; i < words.length; i++) {
		var tspan = el.append('tspan').text(words[i]);
		if (i > 0)
		    tspan.attr('x', 0).attr('dy', '15');
	    }
	};
	
    
	// remove edges associated with a node
	thisGraph.spliceLinksForNode = function(node) {
	    var thisGraph = this,
		toSplice = thisGraph.edges.filter(function(l) {
		    return (l.source === node || l.target === node);
		});
	    toSplice.map(function(l) {
		thisGraph.edges.splice(thisGraph.edges.indexOf(l), 1);
	    });
	};
	
	thisGraph.replaceSelectEdge = function(d3Path, edgeData){
	    var thisGraph = this;
	    d3Path.classed(thisGraph.consts.selectedClass, true);
	    if (thisGraph.state.selectedEdge){
		thisGraph.removeSelectFromEdge();
	    }
	    thisGraph.state.selectedEdge = edgeData;
	};
	
	thisGraph.replaceSelectNode = function(d3Node, nodeData){
	    var thisGraph = this;
	    d3Node.classed(this.consts.selectedClass, true);
	    if (thisGraph.state.selectedNode){
		thisGraph.removeSelectFromNode();
	    }
	    thisGraph.state.selectedNode = nodeData;
	};
    
	thisGraph.removeSelectFromNode = function(){
	    var thisGraph = this;
	    thisGraph.circles.filter(function(cd){
		return cd.id === thisGraph.state.selectedNode.id;
	    }).classed(thisGraph.consts.selectedClass, false);
	    thisGraph.state.selectedNode = null;
	};
    
	thisGraph.removeSelectFromEdge = function(){
	    var thisGraph = this;
	    thisGraph.paths.filter(function(cd){
		return cd === thisGraph.state.selectedEdge;
	    }).classed(thisGraph.consts.selectedClass, false);
	    thisGraph.state.selectedEdge = null;
	};
    
	thisGraph.pathMouseDown = function(d3path, d){
	    var thisGraph = this,
		state = thisGraph.state;
	    d3.event.stopPropagation();
	    state.mouseDownLink = d;
	    
	    if (state.selectedNode){
		thisGraph.removeSelectFromNode();
	    }
	
	    var prevEdge = state.selectedEdge;
	    if (!prevEdge || prevEdge !== d){
		thisGraph.replaceSelectEdge(d3path, d);
	    } else{
		thisGraph.removeSelectFromEdge();
	    }
	};
	
	// mousedown on node
	thisGraph.circleMouseDown = function(d3node, d){
	    var thisGraph = this,
		state = thisGraph.state;
	    d3.event.stopPropagation();
	    state.mouseDownNode = d;
	    if (d3.event.shiftKey){
		state.shiftNodeDrag = d3.event.shiftKey;
		// reposition dragged directed edge
		thisGraph.dragLine.classed('hidden', false)
		    .attr('d', 'M' + d.x + ',' + d.y + 'L' + d.x + ',' + d.y);
		return;
	    }
	};
	
	/* place editable text on node in place of svg text */
	thisGraph.changeTextOfNode = function(d3node, d){
	    var thisGraph= this,
		consts = thisGraph.consts,
		htmlEl = d3node.node();
	    d3node.selectAll("text").remove();
	    var nodeBCR = htmlEl.getBoundingClientRect(),
		curScale = nodeBCR.width/consts.nodeRadius,
		placePad  =  5*curScale,
		useHW = curScale > 1 ? nodeBCR.width*0.71 : consts.nodeRadius*1.42;
	    // replace with editableconent text
	    var d3txt = thisGraph.svg.selectAll("foreignObject")
		.data([d])
		.enter()
		.append("foreignObject")
		.attr("x", d.x- consts.nodeRadius*0.7)
		.attr("y", d.y- consts.nodeRadius*1.3)
		.attr("height", useHW)
		.attr("width", useHW)
		.append("xhtml:p")
		.attr("id", consts.activeEditId)
		.attr("contentEditable", "true")
		.text(d.title)
		.on("mousedown", function(d){
		    d3.event.stopPropagation();
		})
		.on("keydown", function(d){
		    d3.event.stopPropagation();
		    if (d3.event.keyCode == consts.ENTER_KEY && !d3.event.shiftKey){
			this.blur();
		    }
		})
		.on("blur", function(d){
		    d.title = this.textContent;
		    thisGraph.insertTitleLinebreaks(d3node, d.title);
		    d3.select(this.parentElement).remove();
		});
	    return d3txt;
	};
    
	// mouseup on nodes
	thisGraph.circleMouseUp = function(d3node, d){
	    var thisGraph = this,
		state = thisGraph.state,
		consts = thisGraph.consts;
	    // reset the states
	    state.shiftNodeDrag = false;
	    d3node.classed(consts.connectClass, false);
	    
	    var mouseDownNode = state.mouseDownNode;
	    
	    if (!mouseDownNode) return;
	    
	    thisGraph.dragLine.classed("hidden", true);
	    
	    if (mouseDownNode !== d){
		// we're in a different node: create new edge for mousedown edge and add to graph
		var newEdge = {source: mouseDownNode, target: d};
		var filtRes = thisGraph.paths.filter(function(d){
		    if (d.source === newEdge.target && d.target === newEdge.source){
			thisGraph.edges.splice(thisGraph.edges.indexOf(d), 1);
		    }
		    return d.source === newEdge.source && d.target === newEdge.target;
		});
		if (!filtRes[0].length){
		    thisGraph.edges.push(newEdge);
		    thisGraph.updateGraph();
		}
	    } else{
		// we're in the same node
		if (state.justDragged) {
		    // dragged, not clicked
		    state.justDragged = false;
		} else{
		    // clicked, not dragged
		    if (d3.event.shiftKey){
			// shift-clicked node: edit text content
			var d3txt = thisGraph.changeTextOfNode(d3node, d);
			var txtNode = d3txt.node();
			thisGraph.selectElementContents(txtNode);
			txtNode.focus();
		    } else{
			if (state.selectedEdge){
			    thisGraph.removeSelectFromEdge();
			}
			var prevNode = state.selectedNode;
			
			if (!prevNode || prevNode.id !== d.id){
			    thisGraph.replaceSelectNode(d3node, d);
			} else{
			    thisGraph.removeSelectFromNode();
			}
		    }
		}
	    }
	    state.mouseDownNode = null;
	    return;
	
	}; // end of circles mouseup
    
	// mousedown on main svg
	thisGraph.svgMouseDown = function(){
	    this.state.graphMouseDown = true;
	};
    
	// mouseup on main svg
	thisGraph.svgMouseUp = function(){
	    var thisGraph = this,
		state = thisGraph.state;
	  
	    if (state.justScaleTransGraph) {
		// dragged not clicked
		state.justScaleTransGraph = false;
	    } else if (state.graphMouseDown && d3.event.shiftKey){
		// clicked not dragged from svg
		var xycoords = d3.mouse(thisGraph.svgG.node()),		    
		    d = { title:  thisGraph.idct.toString(), id: thisGraph.idct++, x: xycoords[0], y: xycoords[1]};
		thisGraph.nodes.push(d);
		thisGraph.updateGraph();
		// make title of text immediently editable
		var d3txt = thisGraph.changeTextOfNode(thisGraph.circles.filter(function(dval){
		    return dval.id === d.id;
		}), d),
		    txtNode = d3txt.node();
		thisGraph.selectElementContents(txtNode);
		txtNode.focus();
	    } else if (state.shiftNodeDrag){
		// dragged from node
		state.shiftNodeDrag = false;
		thisGraph.dragLine.classed("hidden", true);
	    }
	    state.graphMouseDown = false;
	};

	// keydown on main svg
	thisGraph.svgKeyDown = function() {
	    var thisGraph = this,
		state = thisGraph.state,
		consts = thisGraph.consts;
	    // make sure repeated key presses don't register for each keydown
	    if(state.lastKeyDown !== -1) return;
	    state.lastKeyDown = d3.event.keyCode;
	    var selectedNode = state.selectedNode,
		selectedEdge = state.selectedEdge;
	    switch(d3.event.keyCode) {
	    case consts.BACKSPACE_KEY:
	    case consts.DELETE_KEY:
		d3.event.preventDefault();
		if (selectedNode){
		    thisGraph.nodes.splice(thisGraph.nodes.indexOf(selectedNode), 1);
		    thisGraph.spliceLinksForNode(selectedNode);
		    state.selectedNode = null;
		    thisGraph.updateGraph();
		} else if (selectedEdge){
		    thisGraph.edges.splice(thisGraph.edges.indexOf(selectedEdge), 1);
		    state.selectedEdge = null;
		    thisGraph.updateGraph();
		}
		break;
	    }
	};
	
	thisGraph.svgKeyUp = function() {
	    this.state.lastKeyDown = -1;
	};
	// call to propagate changes to graph
	thisGraph.updateGraph = function(){
	    
	    var thisGraph = this,
		consts = thisGraph.consts,
		state = thisGraph.state;
	    
	    thisGraph.paths = thisGraph.paths.data(thisGraph.edges, function(d){
		return String(d.source.id) + "+" + String(d.target.id);
	    });
	    var paths = thisGraph.paths;
	    paths
		.classed(consts.selectedClass, function(d){
		    return d === state.selectedEdge;
		})
		.attr("d", function(d){
		    return "M" + d.source.x + "," + d.source.y + "L" + d.target.x + "," + d.target.y;
		});
	    // add new paths
	    paths.enter()
		.append("path")
		.classed("link", true)
		.attr("d", function(d){
		    return "M" + d.source.x + "," + d.source.y + "L" + d.target.x + "," + d.target.y;
		})
		.on("mousedown", function(d){
		    thisGraph.pathMouseDown.call(thisGraph, d3.select(this), d);
		}
		   )
		.on("mouseup", function(d){
		    state.mouseDownLink = null;
	    });
	    
	    // remove old links
	    paths.exit().remove();
	    
	    // update existing nodes
	    thisGraph.circles = thisGraph.circles.data(thisGraph.nodes, function(d){ return d.id;});
	    thisGraph.circles.attr("transform", function(d){
		return "translate(" + d.x + "," + d.y + ")";});
	    
	    // add new nodes
	    var newGs= thisGraph.circles.enter()
		.append("g");
	
	    newGs.classed(consts.circleGClass, true)
		.attr("transform", function(d){return "translate(" + d.x + "," + d.y + ")";})
		.on("mouseover", function(d){
		    if (state.shiftNodeDrag){
			d3.select(this).classed(consts.connectClass, true);
		    }
		})
		.on("mouseout", function(d){
		    d3.select(this).classed(consts.connectClass, false);
		})
		.on("mousedown", function(d){
		    thisGraph.circleMouseDown.call(thisGraph, d3.select(this), d);
		})
		.on("mouseup", function(d){
		    thisGraph.circleMouseUp.call(thisGraph, d3.select(this), d);
		})
		.call(thisGraph.drag);
	    
	    newGs.append("circle")
		.attr("r", String(consts.nodeRadius));
	    
	    newGs.each(function(d){
		thisGraph.insertTitleLinebreaks(d3.select(this), d.title);
	    });
	    
	    // remove old nodes
	    thisGraph.circles.exit().remove();
	};
	/*
	thisGraph.zoomed = function(){
	    this.state.justScaleTransGraph = true;
	    d3.select("." + this.consts.graphClass)
		.attr("transform", "translate(" + d3.event.translate + ") scale(" + d3.event.scale + ")");
	};
	
	thisGraph.updateWindow = function(svg){
	    var docEl = document.documentElement,
		bodyEl = document.getElementsByTagName('body')[0];
	    var x = window.innerWidth || docEl.clientWidth || bodyEl.clientWidth;
	    var y = window.innerHeight|| docEl.clientHeight|| bodyEl.clientHeight;
	    svg.attr("width", x).attr("height", y);
	};
	*/
	
    };
    

    
    /**** MAIN ****/

    // warn the user when leaving
    window.onbeforeunload = function(){
	return "Make sure to save your graph locally before leaving :-)";
    };
    
    var docEl = document.documentElement,
	bodyEl = document.getElementsByTagName('body')[0];
    
    var width = window.innerWidth || docEl.clientWidth || bodyEl.clientWidth,
	height =  window.innerHeight|| docEl.clientHeight|| bodyEl.clientHeight;
    var svg_width = width/3;
    var svg_height = height;

    var xLoc = width/2 - 25,
	yLoc = 100;
    
    // initial node data
    var nodes = [];
    var edges = [];
    
    var nodes2 = [];
    var edges2 = [];
 
    /** MAIN SVG **/
    var title1 = d3.select("#title").append("svg")
	.attr("width", width/3)
	.attr("height", "30px")
	.style('background-color',"#b3e2cd")
	.append("text")
	.attr("x", width/6-70)
	.attr("y", 25)
	.attr("font-family", "sans-serif")
	.attr("font-size", "20px")
	.text("Merge Tree 1");

    var title2 = d3.select("#title").append("svg")
	.attr("width", width/3)
	.attr("height", "30px")
	.style('background-color',"#cccccc")
	.append("text")
	.attr("x", width/6-70)
	.attr("y", 25)
	.attr("font-family", "sans-serif")
	.attr("font-size", "20px")
	.text("Merge Tree 2");

    var title3 = d3.select("#title").append("svg")
	.attr("width", width/3)
	.attr("height", "30px")
	.style('background-color',"#fdcdac")
	.append("text")
	.attr("x", width/6-60)
	.attr("y", 20)
	.attr("font-family", "sans-serif")
	.attr("font-size", "20px")
	.text("Average Tree");;
    
    
    var svg = d3.select(settings.appendElSpec1).append("svg")
        .attr("width", width/3)
	.attr("height", height)
	.on('mouseover', function() {
	    d3.select(this)
		.style('background-color',"#b3e2cd");
	})
	.on('mouseout', function () {
	    d3.select(this)
		.style('background-color', function (d) { return "white"; })
	});
    

    
    var svg2 = d3.select(settings.appendElSpec2).append("svg")
        .attr("width", width/3)
	.attr("height", height)
	.on('mouseover', function() {
	    d3.select(this)
		.style('background-color',"#cccccc")
	})
	.on('mouseout', function () {
	    d3.select(this)
		.style('background-color', function (d) { return "white"; })
	});

    var graph = new GraphCreator(svg, nodes, edges, settings.appendElSpec1);
    graph.setIdCt(1);
    graph.updateGraph();
    
    var graph2 = new GraphCreator(svg2, nodes2, edges2, settings.appendElSpec2);
    graph2.setIdCt(1);
    graph2.updateGraph();

    
    var svg3 = d3.select(settings.appendElSpec3).append("svg")
        .attr("width", width/3)
	.attr("height", height)
	.on('mouseover', function() {
	    d3.select(this)
		.style('background-color',"#fdcdac")
	})
	.on('mouseout', function () {
	    d3.select(this)
		.style('background-color', function (d) { return "white"; })
	});

    d3.select("#start").on("click", function(){
	sent2python(nodes, edges, nodes2, edges2, svg_width, svg_height, svg3);
    });


    function sent2python (nodes, edges, nodes2, edges2, svg_width, svg_height, svg){
	var params = {
	    Nodes1: nodes,
	    Nodes2: nodes2,
	    Edges1: edges,
	    Edges2: edges2,
	    width:  svg_width,
	    height:  svg_height
	};

	$.ajax(
	    {
		type: "POST",
		url: "/api/say_name",
		contentType: 'application/json; charset=utf-8',
		data: JSON.stringify(params),
		dataType: "json",
		success: function (response)
		{
		    draw_tree(response, svg); 
		},
	    });
	
	
    }
    
    function draw_tree(data, svg){
	var paths = svg.selectAll("path")
	    .data(data.edges);

	paths.enter().append("path")
	    .style("fill", "none")
	    .style("stroke", "#333")
	    .style("stroke-width", "4px")
	    .style("cursor", "default");

	paths
	    .attr("d", function(d){
		return "M" + d.source.x + "," + d.source.y + "L" + d.target.x + "," + d.target.y;
	    })
	.style("opacity", 0)
	    .transition()
	    .duration(1000)
	    .style("opacity",1);

	var circle = svg.selectAll("circle")
	    .data(data.nodes);

	circle.enter().append("circle")
	    .attr("r", String(30))
	    .style("fill",  "#333")
	    .style("stroke", "#333")
	    .style("stroke-width", "2px");
	circle
	    .attr("transform", function(d){
		return "translate(" + d.x + "," + d.y + ")";})
	    .style("opacity", 0)
	    .transition()
	    .duration(1000)
	    .style("opacity",1);
	circle.exit().transition().duration(1000).remove();
	paths.exit().transition().duration(1000).remove();

	d3.selection.prototype.moveToFront = function() {  
	    return this.each(function(){
		this.parentNode.appendChild(this);
	    });
	};
	
	var text = svg.selectAll("text")
	    .data(data.nodes);

	text.enter().append("text")
	    .attr("text-anchor","middle")
	    .attr("dy", "6px")
	    .attr("font-size", "25px")
	    .attr("fill","#F6FBFF");

	text
	    .attr("x", function(d){return d.x;})
	    .attr("y", function(d){return d.y;})
	    .text(function(d){return d.title;})
	    .style("opacity", 0)
	    .transition()
	    .duration(1000)
	    .style("opacity",1);

	text.each(function(d){
	    d3.select(this).moveToFront();
	});

	text.exit().transition().duration(1000).remove();

    };
    
})(window.d3, window.saveAs, window.Blob);

